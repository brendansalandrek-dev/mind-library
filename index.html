<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Mind Library</title>
  <style>
    :root {
      --bg:#0f1115;
      --panel:#171a21;
      --text:#e7eaf0;
      --muted:#9aa3b2;

      --wood1:#3a2417;
      --wood2:#2b1a12;
      --wood3:#4a2d1c;

      --wallW: clamp(10px, 2.2vw, 18px);
      --innerGap: clamp(6px, 1.4vw, 12px);
      --safeL: env(safe-area-inset-left, 0px);
      --safeR: env(safe-area-inset-right, 0px);
    }

    * { box-sizing: border-box; }
    body {
      margin:0;
      font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial;
      background:var(--bg);
      color:var(--text);
    }

    header {
      padding:12px 14px 10px;
      position:sticky; top:0; z-index:10;
      background:linear-gradient(#0f1115, rgba(15,17,21,.92));
      backdrop-filter: blur(6px);
      border-bottom: 1px solid rgba(255,255,255,.06);
    }
    .titleRow { display:flex; align-items:center; justify-content:space-between; gap:10px; }
    h1 { margin:0; font-size:16px; font-weight:650; letter-spacing:.2px; }
    .sub { margin-top:6px; color:var(--muted); font-size:12px; white-space: pre-wrap; }

    .wrap {
      position: relative;
      padding-bottom: 22px;
      padding-left:  calc(16px + var(--wallW) + var(--innerGap) + var(--safeL));
      padding-right: calc(16px + var(--wallW) + var(--innerGap) + var(--safeR));
      max-width: 980px;
      margin: 0 auto;
      background: linear-gradient(180deg, var(--wood1), var(--wood2));
      border-radius: 18px;
      border: 1px solid rgba(255,255,255,.10);
      box-shadow:
        0 14px 40px rgba(0,0,0,.45),
        inset 0 0 0 1px rgba(0,0,0,.35);
      overflow: hidden;
    }

    #bookCountBadge{
      font-size: 12px;
      font-weight: 800;
      color: rgba(255,255,255,.85);
      padding: 4px 10px;
      border-radius: 999px;
      background: rgba(255,255,255,.10);
      border: 1px solid rgba(255,255,255,.14);
      line-height: 1.6;
      user-select: none;
    }

    .wrap::before,
    .wrap::after {
      content: "";
      position: absolute;
      top: 0;
      bottom: 0;
      width: var(--wallW);
      z-index: 5;
      background: linear-gradient(180deg, var(--wood3), var(--wood2));
      box-shadow: inset 0 0 0 2px rgba(0,0,0,.22);
      pointer-events: none;
    }
    .wrap::before { left: 0; border-right: 1px solid rgba(255,255,255,.08); }
    .wrap::after { right: 0; border-left: 1px solid rgba(255,255,255,.08); }

    .grid {
      position: relative;
      z-index: 1;
      display: flex;
      flex-wrap: wrap;
      align-items: flex-end;
      row-gap: 22px;
      padding: 20px var(--innerGap);
      border-radius: 14px;
      border: 1px solid rgba(255,255,255,.06);
      overflow: hidden;
      background:
        linear-gradient(180deg, rgba(255,255,255,.06), rgba(255,255,255,0)),
        repeating-linear-gradient(
          180deg,
          rgba(0,0,0,.28) 0px,
          rgba(0,0,0,.28) 2px,
          rgba(0,0,0,0) 2px,
          rgba(0,0,0,0) 292px
        );
    }

    .panel {
      margin-top:14px;
      border-radius:14px;
      background: var(--panel);
      border: 1px solid rgba(255,255,255,.08);
      padding:12px;
    }
    .row { display:flex; gap:10px; flex-wrap:wrap; align-items:end; }
    label { display:block; font-size:12px; color:var(--muted); margin-bottom:6px; }
    input[type="text"], input[type="color"], input[type="number"], select {
      background:#0f1115; color:var(--text);
      border: 1px solid rgba(255,255,255,.12);
      border-radius:12px;
      padding:10px 12px;
      font-size:14px;
    }
    input[type="text"]{ min-width: 220px; }
    input[type="number"]{ width: 120px; }

    button {
      background:#0f1115; color:var(--text);
      border: 1px solid rgba(255,255,255,.14);
      border-radius:12px;
      padding:9px 10px;
      font-size:13px;
      cursor:pointer;
      touch-action: manipulation;
    }
    button.primary { background: rgba(255,255,255,.12); }
    button.danger { border-color: rgba(255,100,100,.35); }
    button.small { padding:7px 9px; font-size:12px; }
    button.ghost { background: transparent; }

    .textPreview {
      width: 32px;
      height: 32px;
      border-radius: 8px;
      border: 1px solid rgba(255,255,255,.2);
      display: flex;
      align-items: center;
      justify-content: center;
      font-weight: 900;
      font-size: 14px;
      user-select: none;
      line-height: 1;
    }

    /* MAIN SHELF BOOKS */
    .book { width: 50px; background: transparent; border:0; box-shadow:none; overflow:visible; position:relative; }
    .book .meta, .book .badge { display:none !important; }

    .spine {
      position: relative;
      width: 50px;
      height: 250px;
      border-radius: 16px;
      box-shadow: inset 0 0 0 1px rgba(255,255,255,.18), 0 12px 24px rgba(0,0,0,.25);
      display:flex; align-items:center; justify-content:center;
      padding:8px;
      pointer-events:auto;
    }
    .spine span {
      writing-mode: vertical-rl;
      font-weight: 700;
      letter-spacing:.6px;
      font-size: 13px;
      color: rgba(255,255,255,.92);
      text-shadow: 0 1px 2px rgba(0,0,0,.35);
      user-select:none;
      text-align:center;
      pointer-events:none;
    }
    .gearBtn {
      position:absolute; left:50%; transform:translateX(-50%);
      bottom:-10px; width:40px; height:32px; border-radius:12px;
      background: rgba(255,255,255,.12);
      border: 1px solid rgba(255,255,255,.14);
      cursor:pointer; font-size:16px; z-index:3;
    }
    .openBtn{
      position:absolute; left:50%; transform:translateX(-50%);
      top:-10px; width:40px; height:32px; border-radius:12px;
      background: rgba(255,255,255,.12);
      border: 1px solid rgba(255,255,255,.14);
      cursor:pointer; font-size:16px; z-index:3;
      display:flex; align-items:center; justify-content:center;
    }

    .book.active .spine {
      transform: translateY(-10px) rotate(-2deg);
      box-shadow: inset 0 0 0 1px rgba(255,255,255,.22), 0 18px 36px rgba(0,0,0,.55);
      outline: 2px solid rgba(255,255,255,.18);
    }
    /* Active book stays visible (dimmed) so the shelf never looks empty */
.book.active{
  opacity: .45;
  pointer-events: auto;
}
.book.active .openBtn{
  display:none; /* already active, so hide the "make active" button */
}

    #topShelf{ display:flex; flex-direction:column; gap:8px; margin:0 0 6px; padding:0; }
    .topRow { position:relative; display:flex; align-items:center; justify-content:flex-start; }
    .topSpine{
      width:250px; height:50px; border-radius:14px;
      cursor:pointer; user-select:none;
      box-shadow: inset 0 0 0 1px rgba(255,255,255,.18), 0 12px 24px rgba(0,0,0,.35);
      display:flex; align-items:center; justify-content:center; position:relative;
    }
    .topSpine span{ font-weight:700; letter-spacing:.6px; font-size:13px; color:rgba(255,255,255,.92); text-shadow:0 1px 2px rgba(0,0,0,.35); }
    .topGearBtn, .topOpenBtn{
      position:absolute; top:12px; width:40px; height:32px; border-radius:12px;
      background: rgba(255,255,255,.12);
      border: 1px solid rgba(255,255,255,.14);
      cursor:pointer; font-size:16px; z-index:4;
      display:flex; align-items:center; justify-content:center;
    }
    .topGearBtn{ right:14px; }
    .topOpenBtn{ right:60px; }

    /* Book View */
    .bookViewBg{
      position: fixed; inset: 0;
      background: rgba(0,0,0,.65);
      display:none; z-index:80;
      padding:14px;
      padding-left: calc(14px + var(--safeL));
      padding-right: calc(14px + var(--safeR));
    }
    .bookView{
      width: min(1100px, 100%);
      height: calc(100dvh - 28px);
      margin: 0 auto;
      background: linear-gradient(180deg, rgba(23,26,33,.98), rgba(23,26,33,.92));
      border: 1px solid rgba(255,255,255,.10);
      border-radius: 18px;
      box-shadow: 0 20px 60px rgba(0,0,0,.55);
      display:flex; flex-direction:column;
      overflow:hidden;
    }
    .bookViewTop{
      display:flex; align-items:center; justify-content:space-between; gap:10px;
      padding:12px;
      border-bottom: 1px solid rgba(255,255,255,.08);
    }
    .bookCrumbs{
      font-size:12px; color: rgba(255,255,255,.75);
      white-space: nowrap; overflow:hidden; text-overflow:ellipsis;
    }
    .bookCutBar{
      padding: 10px 12px;
      border-bottom: 1px solid rgba(255,255,255,.08);
      display:none;
    }

    /* ‚úÖ NEW: global notes controls (doesn't steal height from only one page) */
.notesGlobalBar{
  padding: 10px 12px;
  border-bottom: 1px solid rgba(255,255,255,.08);
  display:none;
  touch-action: pan-y; /* allow vertical scroll, horizontal swipe detection */
}
    .notesGlobalRow{
      display:flex; align-items:center; gap:10px; flex-wrap:wrap;
    }
    .notesGlobalRow .spacer{ flex:1; }
    .notesPager{
      display:flex; align-items:center; gap:10px;
      padding: 6px 10px;
      border-radius: 999px;
      background: rgba(0,0,0,.18);
      border: 1px solid rgba(255,255,255,.10);
    }
    .pageNum{ font-size:12px; color: rgba(255,255,255,.85); font-weight:800; }

/* Selected notes page outline (desktop spread selection) */
.page.selected{
  outline: 2px solid rgba(255,255,255,.22);
  outline-offset: -6px;
}

    .bookPages{
      flex:1;
      display:grid;
      grid-template-columns: 1fr 1fr;
      gap:0;
      overflow:auto;
      -webkit-overflow-scrolling: touch;
      touch-action: pan-y;
      overscroll-behavior: contain;
    }

    .page{
      padding:14px;
      display:flex;
      flex-direction:column;
      min-height:0;
    }
    .leftPage{
      border-right: 1px solid rgba(255,255,255,.08);
      background: linear-gradient(180deg, rgba(58,36,23,.35), rgba(43,26,18,.25));
    }
    .rightPage{
      background: linear-gradient(180deg, rgba(255,255,255,.05), rgba(255,255,255,0));
    }
    .pageHeader{ font-weight:800; font-size:13px; margin-bottom:10px; color: rgba(255,255,255,.92); }
    .bookTitle{ font-size:18px; font-weight:900; margin-bottom:10px; }

    .settingsRow{ display:flex; gap:10px; flex-wrap:wrap; align-items:end; }

    textarea{
      width:100%;
      background:#0f1115; color:var(--text);
      border: 1px solid rgba(255,255,255,.12);
      border-radius:12px;
      padding:10px 12px;
      font-size:14px;
      line-height:1.35;
      resize:none;
      flex:1;
      min-height:0;
    }
    textarea:disabled{ opacity:0.55; }

    .notesBlock{
      flex:1;
      display:flex;
      flex-direction:column;
      min-height:0;
    }
    .inlineTitleBox{ margin-bottom:10px; }
    .inlineTitleBox input{ width:100%; min-width:0; }

    /* Contents list */
    .contentsHint{ font-size:12px; color: var(--muted); margin-bottom:12px; }
    .contentsList{
      border: 1px solid rgba(255,255,255,.10);
      border-radius: 14px;
      overflow:hidden;
    }
    .contentsItem{
      display:flex; align-items:center; justify-content:space-between; gap:10px;
      padding: 10px 12px;
      cursor:pointer;
      background: rgba(0,0,0,.18);
      border-bottom: 1px solid rgba(255,255,255,.08);
    }
    .contentsItem:last-child{ border-bottom:0; }
    .contentsItem:hover{ background: rgba(255,255,255,.06); }
    .contentsTitle{ font-weight:800; font-size:13px; }
    .contentsMeta{ font-size:12px; color: rgba(255,255,255,.70); }

    /* Mini shelf */
    .miniShelf{
      display:flex; flex-wrap:wrap; row-gap:18px; align-items:flex-end;
      padding:14px 10px;
      border-radius:14px;
      border: 1px solid rgba(255,255,255,.08);
      background:
        linear-gradient(180deg, rgba(255,255,255,.05), rgba(255,255,255,0)),
        repeating-linear-gradient(
          180deg,
          rgba(0,0,0,.22) 0px,
          rgba(0,0,0,.22) 2px,
          rgba(0,0,0,0) 2px,
          rgba(0,0,0,0) 292px
        );
      min-height:320px;
    }
    .miniBook{ position:relative; width:50px; height:250px; }
    .miniSpine{
      width:50px; height:250px; border-radius:16px;
      display:flex; align-items:center; justify-content:center;
      box-shadow: inset 0 0 0 1px rgba(255,255,255,.18), 0 12px 24px rgba(0,0,0,.25);
      cursor:pointer; user-select:none;
    }
    .miniSpine span{
      writing-mode: vertical-rl;
      font-weight:700;
      letter-spacing:.7px;
      font-size:13px;
      color: rgba(255,255,255,.92);
      text-shadow:0 1px 2px rgba(0,0,0,.35);
      pointer-events:none;
    }
    .miniOpenBtn, .miniGearBtn{
      position:absolute; left:50%; transform: translateX(-50%);
      width:40px; height:32px; border-radius:12px;
      background: rgba(255,255,255,.12);
      border: 1px solid rgba(255,255,255,.14);
      cursor:pointer; font-size:16px; z-index:3;
      display:flex; align-items:center; justify-content:center;
    }
    .miniOpenBtn{ top:-10px; }
    .miniGearBtn{ bottom:-10px; }

    .miniAdd{
      margin-top:12px;
      padding-top:12px;
      border-top: 1px solid rgba(255,255,255,.08);
    }

    /* ---- View switching ---- */
    @media (min-width: 781px){
      /* Desktop default: Front + Contents */
      .bookView:not([data-view="notes"]) #notesLeftPage,
      .bookView:not([data-view="notes"]) #notesRightPage { display:none; }

      /* Desktop notes: Notes spread only */
      .bookView[data-view="notes"] #frontPage,
      .bookView[data-view="notes"] #contentsPage { display:none; }
    }

@media (max-width: 780px){
  /* Mobile: always single column */
  .bookPages{ grid-template-columns: 1fr; }

  .leftPage{ border-right:0; border-bottom: 1px solid rgba(255,255,255,.08); }

  /* ‚úÖ Mobile view switching: ONLY show the active page */
  .bookView[data-view="front"] #contentsPage,
  .bookView[data-view="front"] #notesLeftPage,
  .bookView[data-view="front"] #notesRightPage { display:none !important; }

  .bookView[data-view="contents"] #frontPage,
  .bookView[data-view="contents"] #notesLeftPage,
  .bookView[data-view="contents"] #notesRightPage { display:none !important; }

  /* ‚úÖ Mobile notes mode: show ONLY ONE notes page */
  .bookView[data-view="notes"] #notesRightPage { display:none !important; }
  .bookView[data-view="notes"] #notesLeftPage{ border-bottom: 0 !important; }
  .bookView[data-view="notes"] #frontPage,
  .bookView[data-view="notes"] #contentsPage { display:none !important; }
}
  </style>
</head>

<body>
<header>
  <div class="titleRow">
    <div style="display:flex; align-items:center; gap:10px;">
      <h1 style="margin:0;">Mind Library</h1>
      <span id="bookCountBadge" title="Total books in library (including subfolders)">0</span>
    </div>

    <div style="display:flex; align-items:center; gap:8px;">
      <select id="profileSelect" title="Profile" style="
        background:#0f1115; color:var(--text);
        border: 1px solid rgba(255,255,255,.14);
        border-radius:12px;
        padding:7px 10px;
        font-size:13px;
        cursor:pointer;
      "></select>

      <button type="button" class="small ghost" id="addProfileBtn" title="Add a new profile">Ôºã</button>
      <button type="button" class="small ghost" id="backBtn" title="Go up one level">‚¨Ö Up</button>
    </div>
  </div>

  <div class="sub" id="activeLine">Active: (none)</div>
</header>

<div class="wrap">
  <div id="topShelf"></div>
  <div class="grid" id="grid"></div>

  <div class="panel">
    <div class="row">
      <div>
        <label>Add / create book in current folder</label>
        <input id="name" type="text" placeholder="e.g., Rest" />
      </div>

      <div>
        <label>Colour</label>
        <div style="display:flex; align-items:center; gap:10px;">
          <input id="color" type="color" value="#6b7280" />
          <div id="colorPreview" style="width:32px; height:32px; border-radius:8px; border:1px solid rgba(255,255,255,.2);"></div>
        </div>
      </div>

      <div>
        <label>Text colour</label>
        <div style="display:flex; align-items:center; gap:10px;">
          <select id="textColor">
            <option value="#000000">Black</option>
            <option value="#333333">Dark grey</option>
            <option value="#777777">Mid grey</option>
            <option value="#cccccc">Light grey</option>
            <option value="#ffffff" selected>White</option>
          </select>
          <div id="textColorPreview" class="textPreview">T</div>
        </div>
      </div>

      <div><button type="button" class="primary" id="addBtn">Add book</button></div>
    </div>

    <div class="row" style="margin-top:10px;">
      <div><button type="button" id="exportBtn">Export backup</button></div>
      <div><button type="button" id="importBtn">Import backup</button></div>
      <input type="file" id="importFile" accept="application/json" style="display:none;">

      <div><button type="button" id="exportBookBtn">Export active book</button></div>
      <div><button type="button" id="importBookBtn">Import book here</button></div>
      <input type="file" id="importBookFile" accept="application/json" style="display:none;">
    </div>

    <hr style="border:0;border-top:1px solid rgba(255,255,255,.08); margin:12px 0;">

    <div class="row" style="margin-top:10px;">
      <div><button type="button" id="clearActiveBtn">Clear active</button></div>
    </div>
  </div>
</div>

<!-- Book View -->
<div class="bookViewBg" id="bookViewBg" aria-hidden="true">
  <div class="bookView" role="dialog" aria-modal="true" data-view="front">

    <div class="bookViewTop">
      <div class="bookCrumbs" id="bookCrumbs"></div>

      <div style="display:flex; gap:8px; align-items:center;">
        <button type="button" class="small" id="importBookIntoOpenBtn" title="Import a book into this open book">Import</button>
        <input type="file" id="importBookIntoOpenFile" accept="application/json" style="display:none;">
        <button type="button" class="small" id="backBookViewBtn" title="Go back one level">‚¨Ö Back</button>
        <button type="button" id="closeBookViewBtn">Close</button>
      </div>
    </div>

    <div class="bookCutBar" id="bookCutBar"></div>

    <!-- ‚úÖ NEW: unified Notes controls (works for both pages equally) -->
    <div class="notesGlobalBar" id="notesGlobalBar">
      <div class="notesGlobalRow">
        <button type="button" class="small" id="goContentsFromNotesBtn">‚üµ Contents</button>

<div class="notesPager">
  <button type="button" class="small" id="prevPageBtn">‚üµ</button>
  <div class="pageNum" id="pageIndicator">Page 1 / 1</div>
  <button type="button" class="small" id="nextPageBtn">‚ü∂</button>

  <label style="display:flex; align-items:center; gap:6px; margin-left:6px; font-size:12px; color:rgba(255,255,255,.78); user-select:none;">
    <input type="checkbox" id="twoPageModeChk" style="transform: translateY(1px);" />
    2-page
  </label>
</div>

        <div class="spacer"></div>

        <div style="display:flex; gap:8px; flex-wrap:wrap;">
<button type="button" class="small" id="addLeftPageBtn">Add page (Left)</button>
<button type="button" class="small" id="addRightPageBtn">Add page (Right)</button>
<button type="button" class="small danger" id="delPageBtn">Delete page</button>
        </div>
      </div>
    </div>

    <div class="bookPages" id="bookPages">
      <!-- FRONT (left) -->
      <div class="page leftPage" id="frontPage">
        <div class="pageHeader">Book</div>
        <div class="bookTitle" id="bookTitle"></div>

        <div class="settingsRow">
          <div>
            <label>Rename</label>
            <input id="renameInput" type="text" />
          </div>

          <div>
            <label>Colour</label>
            <div style="display:flex; align-items:center; gap:10px;">
              <input id="recolorInput" type="color" />
              <div id="recolorPreview" style="width:32px; height:32px; border-radius:8px; border:1px solid rgba(255,255,255,.2);"></div>
            </div>
          </div>

          <div style="align-self:end;">
            <button type="button" class="primary" id="saveBookSettingsBtn">Save</button>
          </div>
        </div>

        <div style="margin-top:12px;">
          <label>Text colour</label>
          <div style="display:flex; align-items:center; gap:10px;">
            <select id="reTextColor">
              <option value="#000000">Black</option>
              <option value="#333333">Dark grey</option>
              <option value="#777777">Mid grey</option>
              <option value="#cccccc">Light grey</option>
              <option value="#ffffff" selected>White</option>
            </select>
            <div id="reTextPreview" class="textPreview">T</div>
          </div>
        </div>

        <div style="margin-top:14px;">
          <div class="pageHeader">Subfolders</div>
          <div class="miniShelf" id="miniShelf"></div>

          <div class="miniAdd">
            <div style="display:flex; gap:10px; align-items:end; flex-wrap:wrap;">
              <div>
                <label>New subfolder</label>
                <input id="subName" type="text" placeholder="e.g., Emails" />
              </div>

              <div>
                <label>Colour</label>
                <div style="display:flex; align-items:center; gap:10px;">
                  <input id="subColor" type="color" value="#6b7280" />
                  <div id="subColorPreview" style="width:32px; height:32px; border-radius:8px; border:1px solid rgba(255,255,255,.2);"></div>
                </div>
              </div>

              <div>
                <label>Text colour</label>
                <div style="display:flex; align-items:center; gap:10px;">
                  <select id="subTextColor">
                    <option value="#000000">Black</option>
                    <option value="#333333">Dark grey</option>
                    <option value="#777777">Mid grey</option>
                    <option value="#cccccc">Light grey</option>
                    <option value="#ffffff" selected>White</option>
                  </select>
                  <div id="subTextPreview" class="textPreview">T</div>
                </div>
              </div>

              <div><button type="button" class="primary" id="addSubBtn">Add</button></div>
            </div>
          </div>
        </div>

        <div style="margin-top:auto; padding-top:12px; display:flex; justify-content:flex-end;">
          <button type="button" class="small" id="goContentsBtn">Turn page ‚ü∂</button>
        </div>
      </div>

      <!-- CONTENTS (right) -->
      <div class="page rightPage" id="contentsPage">
        <div style="display:flex; align-items:center; gap:10px; flex-wrap:wrap; margin-bottom:12px;">
          <button type="button" class="small" id="goFrontFromContentsBtn">‚üµ Front</button>
          <div class="pageHeader" style="margin:0;">Contents</div>
          <div style="margin-left:auto;">
            <button type="button" class="small" id="goNotesFromContentsBtn">Notes ‚ü∂</button>
          </div>
        </div>

        <div class="contentsHint">Shows pages that have a title. Tap to jump.</div>
        <div id="contentsList" class="contentsList"></div>
      </div>

      <!-- NOTES LEFT (odd or single-page on mobile) -->
      <div class="page leftPage" id="notesLeftPage">
        <div class="notesBlock">
          <div class="inlineTitleBox">
            <label id="notesTitleLabel">Chapter title</label>
            <input id="leftTitleInput" type="text" placeholder="e.g., Chapter: Archetypes" />
          </div>

          <label id="notesTextLabel">Notes</label>
          <textarea id="leftNotesArea" placeholder="- ..."></textarea>
        </div>
      </div>

<!-- NOTES RIGHT (even on desktop only) -->
<div class="page rightPage" id="notesRightPage">
  <div class="notesBlock">

    <div class="inlineTitleBox">
      <label id="rightTitleLabel">Chapter title</label>
      <input id="rightTitleInput" type="text" placeholder="e.g., Chapter: Combat Logic" />
    </div>

    <label id="rightNotesLabel">Notes</label>
    <textarea id="rightNotesArea" placeholder="- ..."></textarea>

  </div>
</div>
  </div>
</div>

<script>

/* =============================
   SAVE IDENTIFIER (LEGACY-COMPAT)
   ============================= */

/*
  ‚úÖ This restores the EXACT old save namespace logic:
  - FILE_ID is derived from location.href (base64 trimmed)
  - Profile 1 uses the original namespace (no suffix)
  - Profile 2+ uses P{n} suffix
  This guarantees the new version will load the old v4 save automatically.
*/

const SAVE_SLOT = "v1";
const REMINDERS_ENABLED = false;

// EXACT legacy FILE_ID method (matches your old working build)
const FILE_ID = btoa(unescape(encodeURIComponent(location.href)))
  .replace(/=+/g, "")
  .slice(0, 24);

// Profile 1 MUST map to the original namespace exactly
const GLOBAL_NS = `ML_${FILE_ID}_${SAVE_SLOT}_`;
const LS_PROFILE = GLOBAL_NS + "profile";
const LS_PCOUNT  = GLOBAL_NS + "profilesCount";

function getProfile() {
  const raw = localStorage.getItem(LS_PROFILE) || "1";
  const n = Math.max(1, parseInt(raw, 10) || 1);
  return String(n);
}
function setProfile(nStr) { localStorage.setItem(LS_PROFILE, String(nStr)); }

function getProfileCount() {
  const raw = localStorage.getItem(LS_PCOUNT) || "1";
  const n = Math.max(1, parseInt(raw, 10) || 1);
  return n;
}
function setProfileCount(n) { localStorage.setItem(LS_PCOUNT, String(Math.max(1, n | 0))); }

// Determine current profile
const PROFILE = getProfile();
const PROFILE_COUNT = getProfileCount();

// Profile namespace:
// - Profile 1: original namespace ‚úÖ preserves existing data
// - Profile 2+: suffix added to keep data separate
const NS = (PROFILE === "1")
  ? `ML_${FILE_ID}_${SAVE_SLOT}_`
  : `ML_${FILE_ID}_${SAVE_SLOT}_P${PROFILE}_`;

// Keys (same pattern as old, plus Book View state for the new version)
const LS_KEY    = NS + "modes";
const LS_ACTIVE = NS + "active";
const LS_PATH   = NS + "path";
const LS_CUT    = NS + "cut";
const LS_BV       = NS + "bookViewState";
const LS_SETTINGS = NS + "settings";

/* =============================
   DOM
   ============================= */
const grid = document.getElementById("grid");
const topShelf = document.getElementById("topShelf");
const activeLine = document.getElementById("activeLine");
const bookCountBadge = document.getElementById("bookCountBadge");
const backBtn = document.getElementById("backBtn");

const nameEl = document.getElementById("name");
const colorEl = document.getElementById("color");
const colorPreview = document.getElementById("colorPreview");
const textColorEl = document.getElementById("textColor");
const textColorPreview = document.getElementById("textColorPreview");

const profileSelect = document.getElementById("profileSelect");
const addProfileBtn = document.getElementById("addProfileBtn");

/* Book view dom */
const bookViewBg = document.getElementById("bookViewBg");
const bookView = bookViewBg.querySelector(".bookView");
const closeBookViewBtn = document.getElementById("closeBookViewBtn");
const backBookViewBtn = document.getElementById("backBookViewBtn");
const bookCrumbs = document.getElementById("bookCrumbs");
const bookCutBar = document.getElementById("bookCutBar");

const notesGlobalBar = document.getElementById("notesGlobalBar");
const prevPageBtn = document.getElementById("prevPageBtn");
const nextPageBtn = document.getElementById("nextPageBtn");
const pageIndicator = document.getElementById("pageIndicator");
const twoPageModeChk = document.getElementById("twoPageModeChk");
const addLeftPageBtn = document.getElementById("addLeftPageBtn");
const addRightPageBtn = document.getElementById("addRightPageBtn");
const delPageBtn = document.getElementById("delPageBtn");
const notesLeftPage = document.getElementById("notesLeftPage");
const notesRightPage = document.getElementById("notesRightPage");
const goContentsFromNotesBtn = document.getElementById("goContentsFromNotesBtn");

const bookPagesEl = document.getElementById("bookPages");

const importBookIntoOpenBtn = document.getElementById("importBookIntoOpenBtn");
const importBookIntoOpenFile = document.getElementById("importBookIntoOpenFile");

const bookTitle = document.getElementById("bookTitle");
const renameInput = document.getElementById("renameInput");
const recolorInput = document.getElementById("recolorInput");
const recolorPreview = document.getElementById("recolorPreview");
const saveBookSettingsBtn = document.getElementById("saveBookSettingsBtn");
const reTextColor = document.getElementById("reTextColor");
const reTextPreview = document.getElementById("reTextPreview");

const miniShelf = document.getElementById("miniShelf");
const subName = document.getElementById("subName");
const subColor = document.getElementById("subColor");
const subColorPreview = document.getElementById("subColorPreview");
const subTextColor = document.getElementById("subTextColor");
const subTextPreview = document.getElementById("subTextPreview");
const addSubBtn = document.getElementById("addSubBtn");

const goContentsBtn = document.getElementById("goContentsBtn");
const goFrontFromContentsBtn = document.getElementById("goFrontFromContentsBtn");
const goNotesFromContentsBtn = document.getElementById("goNotesFromContentsBtn");
const goContentsFromNotesBtn2 = goContentsFromNotesBtn; // alias

const contentsList = document.getElementById("contentsList");

const notesTitleLabel = document.getElementById("notesTitleLabel");
const notesTextLabel = document.getElementById("notesTextLabel");
const rightTitleLabel = document.getElementById("rightTitleLabel");
const rightNotesLabel = document.getElementById("rightNotesLabel");
const leftTitleInput = document.getElementById("leftTitleInput");
const leftNotesArea = document.getElementById("leftNotesArea");
const rightTitleInput = document.getElementById("rightTitleInput");
const rightNotesArea = document.getElementById("rightNotesArea");

// When user clicks/focuses a side of the spread, that page becomes the "selected" page
leftTitleInput.addEventListener("focus", () => {
  if (!window.matchMedia("(max-width: 780px)").matches) selectLeftPageInSpread();
});
leftNotesArea.addEventListener("focus", () => {
  if (!window.matchMedia("(max-width: 780px)").matches) selectLeftPageInSpread();
});

rightTitleInput.addEventListener("focus", () => {
  if (!window.matchMedia("(max-width: 780px)").matches) selectRightPageInSpread();
});
rightNotesArea.addEventListener("focus", () => {
  if (!window.matchMedia("(max-width: 780px)").matches) selectRightPageInSpread();
});

// Desktop: click/tap a notes page to select it (left or right)
notesLeftPage.addEventListener("pointerdown", () => {
  if (bookView.dataset.view !== "notes") return;
  if (window.matchMedia("(max-width: 780px)").matches) return;
  selectLeftPageInSpread();
});

notesRightPage.addEventListener("pointerdown", () => {
  if (bookView.dataset.view !== "notes") return;
  if (window.matchMedia("(max-width: 780px)").matches) return;
  selectRightPageInSpread();
});

/* =============================
   STORAGE HELPERS
   ============================= */
function storageOK() {
  try { localStorage.setItem("__ml_test__", "1"); localStorage.removeItem("__ml_test__"); return true; }
  catch { return false; }
}
if (!storageOK()) {
  document.body.innerHTML = `
    <div style="padding:18px; min-height:100vh; background:#0f1115; color:#e7eaf0;">
      <h2 style="margin:0 0 10px;">Mind Library can‚Äôt run properly here</h2>
      <p style="color:#9aa3b2; line-height:1.45;">
        This environment blocks <b>localStorage</b> (common in iOS preview viewers).
        Open in a normal browser tab (Safari/Chrome) or host via GitHub Pages.
      </p>
    </div>
  `;
  throw new Error("localStorage unavailable");
}

function safeUUID() {
  if (window.crypto && crypto.randomUUID) return crypto.randomUUID();
  return "id_" + Math.random().toString(16).slice(2) + "_" + Date.now();
}
function normalizeHex(val) {
  val = (val || "").trim();
  if (!val.startsWith("#")) val = "#" + val;
  if (!/^#([0-9a-fA-F]{6})$/.test(val)) return "#6b7280";
  return val.toLowerCase();
}
function normalizeTextHex(val) {
  val = (val || "").trim();
  if (!val.startsWith("#")) val = "#" + val;
  if (!/^#([0-9a-fA-F]{6})$/.test(val)) return "#ffffff";
  return val.toLowerCase();
}
function escapeHtml(s) {
  return (s ?? "").replace(/[&<>"']/g, c => ({
    "&":"&amp;","<":"&lt;",">":"&gt;",'"':"&quot;","'":"&#39;"
  }[c]));
}
function deepClone(obj){ return JSON.parse(JSON.stringify(obj)); }

function mkBook(name, color, textColor) {
  return {
    id: safeUUID(),
    name,
    color: normalizeHex(color),
    textColor: normalizeTextHex(textColor),
    notes: "",
    pages: [{ title: "", text: "" }],
    children: []
  };
}
function defaultState() {
  const rest = mkBook("Rest", "#6b7280", "#ffffff");
  return { roots: [rest] };
}
function saveState(state){ localStorage.setItem(LS_KEY, JSON.stringify(state)); }
function loadState(){
  try{
    const raw = localStorage.getItem(LS_KEY);
    if (raw){
      const parsed = JSON.parse(raw);
      if (parsed && Array.isArray(parsed.roots) && parsed.roots.length) return parsed;
    }
  } catch {}
  const st = defaultState();
  saveState(st);
  return st;
}

function getActiveId(){ return localStorage.getItem(LS_ACTIVE) || ""; }
function setActiveId(id){ localStorage.setItem(LS_ACTIVE, id || ""); }

function getCutId(){ return localStorage.getItem(LS_CUT) || ""; }
function setCutId(id){ localStorage.setItem(LS_CUT, id || ""); }

function getPath(){
  try { return JSON.parse(localStorage.getItem(LS_PATH) || "[]"); }
  catch { return []; }
}
function setPath(pathArr){ localStorage.setItem(LS_PATH, JSON.stringify(pathArr)); }

function ensurePages(book){
  if (!book) return;
  if (!Array.isArray(book.pages)) {
    const old = (book.notes || "").toString();
    book.pages = [{ title:"", text: old }];
  } else {
    if (book.pages.length && typeof book.pages[0] === "string") {
      book.pages = book.pages.map(t => ({ title:"", text:(t ?? "").toString() }));
    } else {
      book.pages = book.pages.map(p => ({ title:(p?.title ?? "").toString(), text:(p?.text ?? "").toString() }));
    }
  }
  book.notes = book.pages[0]?.text ?? "";
}
function findBookById(list, id){
  for (const b of list){
    if (b.id === id) return b;
    const inChild = findBookById(b.children || [], id);
    if (inChild) return inChild;
  }
  return null;
}
function countAllBooks(list){
  let total = 0;
  for (const b of (list || [])) { total += 1; total += countAllBooks(b.children || []); }
  return total;
}
function getFolderList(state, pathArr){
  let current = state.roots;
  for (const id of pathArr){
    const folder = current.find(x => x.id === id);
    if (!folder) return state.roots;
    folder.children = folder.children || [];
    current = folder.children;
  }
  return current;
}
function getBreadcrumbNames(state, pathArr){
  const names = [];
  let current = state.roots;
  for (const id of pathArr){
    const folder = current.find(x => x.id === id);
    if (!folder) break;
    names.push(folder.name);
    current = folder.children || [];
  }
  return names;
}
function moveItem(arr, fromIdx, toIdx){
  if (toIdx < 0 || toIdx >= arr.length) return;
  const [item] = arr.splice(fromIdx, 1);
  arr.splice(toIdx, 0, item);
}

function buildBackupObject(){
  return {
    meta: { app:"Mind Library", saveSlot: SAVE_SLOT, createdAt: new Date().toISOString() },
    data: {
      state: loadState(),
      activeId: getActiveId(),
      path: getPath(),
      bookViewState: loadBookViewState()
    }
  };
}
function downloadJson(filename, obj){
  const json = JSON.stringify(obj, null, 2);
  const blob = new Blob([json], { type:"application/json" });
  const url = URL.createObjectURL(blob);
  const a = document.createElement("a");
  a.href = url;
  a.download = filename;
  document.body.appendChild(a);
  a.click();
  a.remove();
  URL.revokeObjectURL(url);
}

/* Import/export book helpers */
function sanitizeImportedBook(raw){
  const book = (raw && raw.book) ? raw.book : raw;
  if (!book || typeof book !== "object") return null;

  const clean = {
    id: book.id || safeUUID(),
    name: (book.name || "Imported Book").toString(),
    color: normalizeHex(book.color || "#6b7280"),
    textColor: normalizeTextHex(book.textColor || "#ffffff"),
    notes: (book.notes || "").toString(),
    children: Array.isArray(book.children) ? book.children : [],
  };

  if (Array.isArray(book.pages)) {
    if (book.pages.length && typeof book.pages[0] === "string") {
      clean.pages = book.pages.map(t => ({ title:"", text:(t ?? "").toString() }));
    } else {
      clean.pages = book.pages.map(p => ({ title:(p?.title ?? "").toString(), text:(p?.text ?? "").toString() }));
    }
  } else {
    clean.pages = [{ title:"", text: clean.notes }];
  }
  clean.notes = clean.pages[0]?.text ?? "";

  clean.children = clean.children.map(child => sanitizeImportedBook(child)).filter(Boolean);
  return clean;
}
function reIdBookTree(book){
  book.id = safeUUID();
  if (Array.isArray(book.children)) for (const c of book.children) reIdBookTree(c);
}
function exportSingleBook(book){
  const stamp = new Date().toISOString().replace(/[:.]/g, "-");
  const safeName = (book.name || "book").toString().replace(/[^\w\- ]+/g, "").trim().replace(/\s+/g, "-");
  const payload = { meta:{ app:"Mind Library", type:"single-book", version:2, exportedAt:new Date().toISOString() }, book: deepClone(book) };
  downloadJson(`mind-library-book-${safeName || "book"}-${stamp}.json`, payload);
}

/* =============================
   PROFILE UI
   ============================= */
function rebuildProfileSelect(){
  const count = getProfileCount();
  profileSelect.innerHTML = "";
  for (let i=1;i<=count;i++){
    const opt = document.createElement("option");
    opt.value = String(i);
    opt.textContent = `Profile ${i}`;
    profileSelect.appendChild(opt);
  }
  profileSelect.value = getProfile();
}
if (parseInt(PROFILE, 10) > PROFILE_COUNT) setProfileCount(parseInt(PROFILE, 10));
rebuildProfileSelect();
profileSelect.addEventListener("change", () => { setProfile(profileSelect.value); location.reload(); });
addProfileBtn.addEventListener("click", () => {
  const next = getProfileCount() + 1;
  setProfileCount(next);
  setProfile(String(next));
  location.reload();
});

/* =============================
   UI PREVIEWS
   ============================= */
function setTextPreview(previewEl, spineHex, textHex){
  if (!previewEl) return;
  previewEl.style.background = spineHex;
  previewEl.style.color = textHex;
  previewEl.textContent = "T";
}
colorPreview.style.background = colorEl.value;
setTextPreview(textColorPreview, colorEl.value, textColorEl.value);

colorEl.addEventListener("input", () => {
  colorPreview.style.background = colorEl.value;
  setTextPreview(textColorPreview, colorEl.value, textColorEl.value);
});
textColorEl.addEventListener("change", () => {
  setTextPreview(textColorPreview, colorEl.value, textColorEl.value);
});

setTextPreview(subTextPreview, subColor.value, subTextColor.value);
subColorPreview.style.background = subColor.value;
subColor.addEventListener("input", () => {
  subColorPreview.style.background = subColor.value;
  setTextPreview(subTextPreview, subColor.value, subTextColor.value);
});
subTextColor.addEventListener("change", () => {
  setTextPreview(subTextPreview, subColor.value, subTextColor.value);
});

/* =============================
   EXPORT / IMPORT (backup + book)
   ============================= */
const exportBtn = document.getElementById("exportBtn");
const importBtn = document.getElementById("importBtn");
const importFile = document.getElementById("importFile");

const exportBookBtn = document.getElementById("exportBookBtn");
const importBookBtn = document.getElementById("importBookBtn");
const importBookFile = document.getElementById("importBookFile");

exportBtn.addEventListener("click", () => {
  const backup = buildBackupObject();
  const stamp = new Date().toISOString().replace(/[:.]/g, "-");
  downloadJson(`mind-library-backup-${SAVE_SLOT}-${stamp}.json`, backup);
});

exportBookBtn.addEventListener("click", () => {
  const activeId = getActiveId();
  if (!activeId) return alert("No active book selected.\n\nClick a book to make it Active, then try again.");
  const state = loadState();
  const book = findBookById(state.roots, activeId);
  if (!book) return alert("Active book not found.");
  ensurePages(book);
  saveState(state);
  exportSingleBook(book);
});

importBtn.addEventListener("click", () => { importFile.value=""; importFile.click(); });
importBookBtn.addEventListener("click", () => { importBookFile.value=""; importBookFile.click(); });

importFile.addEventListener("change", async () => {
  const file = importFile.files && importFile.files[0];
  if (!file) return;
  try {
    const text = await file.text();
    const backup = JSON.parse(text);
    if (!backup || !backup.data || !backup.data.state) return alert("That file doesn't look like a Mind Library backup.");

    const ok = confirm("Importing will overwrite your current library in this SAVE_SLOT.\n\nProceed?");
    if (!ok) return;

    saveState(backup.data.state);
    setActiveId(backup.data.activeId || "");
    setPath(Array.isArray(backup.data.path) ? backup.data.path : []);
    if (backup.data.bookViewState) localStorage.setItem(LS_BV, JSON.stringify(backup.data.bookViewState));

    alert("Import complete.");
    render();

    // Optional: reopen last open book if it was open
    const bv = loadBookViewState();
    if (bv && bv.isOpen) openBookViewFromSaved();
  } catch (e) {
    alert("Import failed. Make sure you selected a valid JSON backup.");
    console.error(e);
  }
});

importBookFile.addEventListener("change", async () => {
  const file = importBookFile.files && importBookFile.files[0];
  if (!file) return;
  try {
    const text = await file.text();
    const raw = JSON.parse(text);
    const clean = sanitizeImportedBook(raw);
    if (!clean) return alert("That file doesn't look like a valid exported book.");

    reIdBookTree(clean);
    ensurePages(clean);

    const state = loadState();
    const folderList = getFolderList(state, getPath());
    folderList.push(clean);

    saveState(state);
    alert(`Book imported into this folder:\n\n${clean.name}`);
    render();
  } catch (e) {
    alert("Import failed. Make sure you selected a valid exported-book JSON file.");
    console.error(e);
  }
});

/* =============================
   MAIN SHELF
   ============================= */
let dragBookId = null;

function render(){
  const state = loadState();
  bookCountBadge.textContent = String(countAllBooks(state.roots));

  const activeId = getActiveId();
  const pathArr = getPath();

  const folderList = getFolderList(state, pathArr);
  const crumbs = getBreadcrumbNames(state, pathArr);
  backBtn.style.visibility = pathArr.length ? "visible" : "hidden";

  const activeBook = activeId ? findBookById(state.roots, activeId) : null;

  // top shelf active
topShelf.innerHTML = activeBook ? `
  <div class="topRow">
    <div class="topSpine" data-act="topOpen" style="background:${activeBook.color}" title="Open book">
      <span style="color:${activeBook.textColor || "#ffffff"}">${escapeHtml(activeBook.name)}</span>
    </div>
    <button type="button" class="topOpenBtn" data-act="topClear" title="Clear active (put back on shelf)">üìñ</button>
    <button type="button" class="topGearBtn" data-act="topGear" title="Options">‚öôÔ∏è</button>
  </div>
` : "";
  activeLine.textContent =
    `Profile ${PROFILE}  ‚Ä¢  ` +
    "Active: " + (activeBook ? activeBook.name : "(none)") +
    (crumbs.length ? `  ‚Ä¢  Folder: ${crumbs.join(" ‚Ä∫ ")}` : "");

  grid.innerHTML = "";
  folderList.forEach((book, i) => {
    const card = document.createElement("div");
    card.className = "book" + (book.id === activeId ? " active" : "");
    card.dataset.bookId = book.id;

    if (book.id !== activeId) {
      card.draggable = true;
      card.addEventListener("dragstart", (e) => {
        dragBookId = book.id;
        card.classList.add("dragging");
        e.dataTransfer.effectAllowed = "move";
      });
      card.addEventListener("dragend", () => {
        dragBookId = null;
        card.classList.remove("dragging");
      });
    }

    card.innerHTML = `
      <div class="spine" style="background:${book.color}">
        <button type="button" class="openBtn" data-act="active" title="Make active">üìñ</button>
        <span style="color:${book.textColor || "#ffffff"}">${escapeHtml(book.name)}</span>
      </div>
      <button type="button" class="gearBtn" data-act="gear" title="Options">‚öôÔ∏è</button>
    `;
    grid.appendChild(card);
  });
}

grid.addEventListener("click", (e) => {
  const btn = e.target.closest("button[data-act]");
  const card = e.target.closest(".book");
  if (!card) return;

  const bookId = card.dataset.bookId;
  const state = loadState();
  const listRef = getFolderList(state, getPath());
  const idx = listRef.findIndex(x => x.id === bookId);
  if (idx < 0) return;

  const b = listRef[idx];

  // üìñ button = Make Active
  if (btn && btn.dataset.act === "active") {
    setActiveId(bookId);
    render();
    return;
  }

  // ‚öôÔ∏è button = Options
  if (btn && btn.dataset.act === "gear") {
    const choice = prompt(
      `Options for "${b.name}":\n\n` +
      `1 = Delete\n` +
      `2 = Move up\n` +
      `3 = Move down\n\n` +
      `Type a number and press OK.`
    );
    if (!choice) return;

    if (choice === "1") {
      const ok = confirm(`Delete "${b.name}"? (Subsections and notes will also be removed)`);
      if (!ok) return;
      listRef.splice(idx, 1);
      if (getActiveId() === bookId) setActiveId("");
      saveState(state);
      render();
      return;
    }
    if (choice === "2") { moveItem(listRef, idx, idx - 1); saveState(state); render(); return; }
    if (choice === "3") { moveItem(listRef, idx, idx + 1); saveState(state); render(); return; }
    return;
  }

  // Clicking the spine/label/anywhere else on the book = OPEN
  openBookView(bookId);
});
grid.addEventListener("dragover", (e) => e.preventDefault());
grid.addEventListener("drop", (e) => {
  e.preventDefault();
  if (!dragBookId) return;

  const state = loadState();
  const listRef = getFolderList(state, getPath());
  const fromIdx = listRef.findIndex(x => x.id === dragBookId);
  if (fromIdx < 0) return;

  const targetCard = e.target.closest(".book");
  const targetId = targetCard ? targetCard.dataset.bookId : null;
  let toIdx = targetId ? listRef.findIndex(x => x.id === targetId) : -1;
  if (toIdx < 0) toIdx = listRef.length - 1;
  if (toIdx === fromIdx) return;

  const [moved] = listRef.splice(fromIdx, 1);
  listRef.splice(toIdx, 0, moved);

  saveState(state);
  render();
});

backBtn.addEventListener("click", () => {
  const pathArr = getPath();
  if (!pathArr.length) return;
  pathArr.pop();
  setPath(pathArr);
  render();
});

document.getElementById("addBtn").addEventListener("click", () => {
  const state = loadState();
  const folderList = getFolderList(state, getPath());

  const nm = (nameEl.value || "").trim();
  if (!nm) return alert("Give the book a name.");
  folderList.push(mkBook(nm, colorEl.value || "#6b7280", textColorEl.value || "#ffffff"));

  saveState(state);
  nameEl.value = "";
  render();
});

document.getElementById("clearActiveBtn").addEventListener("click", () => {
  setActiveId("");
  render();
});

topShelf.addEventListener("click", (e) => {
  const act = e.target.closest("[data-act]")?.dataset.act;
  if (!act) return;

  const activeId = getActiveId();
  if (!activeId) return;

  if (act === "topOpen") {
    openBookView(activeId);
    return;
  }

  if (act === "topClear") {
    setActiveId("");
    render();
    return;
  }

  if (act === "topGear") {
    const state = loadState();
    const listRef = getFolderList(state, getPath());
    const idx = listRef.findIndex(x => x.id === activeId);
    if (idx < 0) return alert("Active book is not in this folder.");

    const b = listRef[idx];
    const choice = prompt(
      `Options for "${b.name}":\n\n` +
      `1 = Delete\n` +
      `2 = Move up\n` +
      `3 = Move down\n\n` +
      `Type a number and press OK.`
    );
    if (!choice) return;

    if (choice === "1") {
      const ok = confirm(`Delete "${b.name}"?`);
      if (!ok) return;
      listRef.splice(idx, 1);
      setActiveId("");
      saveState(state);
      render();
      return;
    }
    if (choice === "2") { moveItem(listRef, idx, idx - 1); saveState(state); render(); return; }
    if (choice === "3") { moveItem(listRef, idx, idx + 1); saveState(state); render(); return; }
  }
});

/* =============================
   BOOK VIEW STATE (remember last place)
   ============================= */
function saveBookViewState(stateObj){
  try { localStorage.setItem(LS_BV, JSON.stringify(stateObj)); } catch {}
}
function loadBookViewState(){
  try { return JSON.parse(localStorage.getItem(LS_BV) || "null"); } catch { return null; }
}

function loadSettings(){
  try {
    const raw = localStorage.getItem(LS_SETTINGS);
    const s = raw ? JSON.parse(raw) : null;
    return {
      twoPageMode: !!s?.twoPageMode,
    };
  } catch {
    return { twoPageMode: false };
  }
}
function saveSettings(s){
  try { localStorage.setItem(LS_SETTINGS, JSON.stringify(s)); } catch {}
}

let SETTINGS = loadSettings();

// ‚úÖ wire checkbox to saved setting
twoPageModeChk.checked = !!SETTINGS.twoPageMode;

twoPageModeChk.addEventListener("change", () => {
  SETTINGS.twoPageMode = !!twoPageModeChk.checked;
  saveSettings(SETTINGS);
  renderBookView();
});

function isTwoPageModeActive(){
  // Only makes sense on wide screens (your layout is 2-column there)
  const isMobile = window.matchMedia("(max-width: 780px)").matches;
  return (!isMobile) && !!SETTINGS.twoPageMode;
}

function getSpreadLeftIndex(){
  return currentPageIndex - (currentPageIndex % 2);
}

function selectPage(idx){
  const state = loadState();
  const book = getCurrentBookFromStack(state);
  if (!book) return;

  ensurePages(book);
  if (idx < 0) idx = 0;
  if (idx > book.pages.length - 1) idx = book.pages.length - 1;

  if (currentPageIndex !== idx){
    currentPageIndex = idx;
    persistOpenState();
    renderBookView();
  }
}

function selectLeftPageInSpread(){
  selectPage(getSpreadLeftIndex());
}

function selectRightPageInSpread(){
  const state = loadState();
  const book = getCurrentBookFromStack(state);
  if (!book) return;

  ensurePages(book);
  const left = getSpreadLeftIndex();
  const right = left + 1;
  if (right >= book.pages.length) return; // no right page exists yet
  selectPage(right);
}

/* =============================
   BOOK VIEW LOGIC
   ============================= */
let bookViewStack = [];
let currentPageIndex = 0;  // ‚úÖ single source of truth: page index (0-based)
let bvDragBookId = null;

function setBookViewMode(mode){
  bookView.dataset.view = mode; // "front" | "contents" | "notes"
  // show/hide notes bar
  notesGlobalBar.style.display = (mode === "notes") ? "block" : "none";

  // persist
  persistOpenState();
}

function persistOpenState(){
  saveBookViewState({
    isOpen: (bookViewBg.style.display === "block"),
    stack: bookViewStack,
    pageIndex: currentPageIndex,
    view: bookView.dataset.view || "front"
  });
}

function getCurrentBookFromStack(state){
  if (!bookViewStack.length) return null;
  return findBookById(state.roots, bookViewStack[bookViewStack.length - 1]);
}

function openBookView(bookId){
  const state = loadState();
  const book = findBookById(state.roots, bookId);
  if (!book) return;

  bookViewStack = [bookId];
  currentPageIndex = 0;

  bookViewBg.style.display = "block";
  bookViewBg.setAttribute("aria-hidden", "false");

  setBookViewMode("front");
  renderBookView();
}

function openBookViewFromSaved(){
  const bv = loadBookViewState();
  if (!bv || !bv.isOpen || !Array.isArray(bv.stack) || !bv.stack.length) return;

  const state = loadState();
  const topId = bv.stack[bv.stack.length - 1];
  const topBook = findBookById(state.roots, topId);
  if (!topBook) return;

  bookViewStack = bv.stack;
  currentPageIndex = Math.max(0, parseInt(bv.pageIndex, 10) || 0);

  bookViewBg.style.display = "block";
  bookViewBg.setAttribute("aria-hidden", "false");

  setBookViewMode(bv.view || "front");
  renderBookView();
}

function closeBookView(){
  bookViewStack = [];
  currentPageIndex = 0;
  bookViewBg.style.display = "none";
  bookViewBg.setAttribute("aria-hidden", "true");

  persistOpenState();
}

closeBookViewBtn.addEventListener("click", closeBookView);

backBookViewBtn.addEventListener("click", () => {
  if (bookViewStack.length > 1) {
    bookViewStack.pop();
    currentPageIndex = 0;
    setBookViewMode("front");
    renderBookView();
  } else {
    closeBookView();
  }
});

bookViewBg.addEventListener("click", (e) => { if (e.target === bookViewBg) closeBookView(); });

document.addEventListener("keydown", (e) => {
  if (e.key !== "Escape") return;
  if (bookViewBg.style.display === "block") closeBookView();
});

/* import into open book */
importBookIntoOpenBtn.addEventListener("click", () => {
  importBookIntoOpenFile.value = "";
  importBookIntoOpenFile.click();
});
importBookIntoOpenFile.addEventListener("change", async () => {
  const file = importBookIntoOpenFile.files && importBookIntoOpenFile.files[0];
  if (!file) return;
  try {
    const text = await file.text();
    const raw = JSON.parse(text);
    const clean = sanitizeImportedBook(raw);
    if (!clean) return alert("That file doesn't look like a valid exported book.");

    reIdBookTree(clean);
    ensurePages(clean);

    const state = loadState();
    const current = getCurrentBookFromStack(state);
    if (!current) return alert("No open book found.");

    current.children = current.children || [];
    current.children.push(clean);

    saveState(state);
    render();
    renderBookView();
  } catch (e) {
    alert("Import failed. Make sure you selected a valid exported-book JSON file.");
    console.error(e);
  }
});

/* Front -> Contents -> Notes nav */
goContentsBtn.addEventListener("click", () => { setBookViewMode("contents"); renderBookView(); });
goFrontFromContentsBtn.addEventListener("click", () => { setBookViewMode("front"); renderBookView(); });
goNotesFromContentsBtn.addEventListener("click", () => { setBookViewMode("notes"); renderBookView(); });
goContentsFromNotesBtn2.addEventListener("click", () => { setBookViewMode("contents"); renderBookView(); });

/* Book settings save */
function updateReTextPreview(){
  setTextPreview(reTextPreview, recolorInput.value || "#6b7280", reTextColor.value || "#ffffff");
}
recolorInput.addEventListener("input", () => { recolorPreview.style.background = recolorInput.value; updateReTextPreview(); });
reTextColor.addEventListener("change", updateReTextPreview);

saveBookSettingsBtn.addEventListener("click", () => {
  const state = loadState();
  const book = getCurrentBookFromStack(state);
  if (!book) return;

  book.name = (renameInput.value || "").trim() || book.name;
  book.color = normalizeHex(recolorInput.value || book.color);
  book.textColor = normalizeTextHex(reTextColor.value || book.textColor || "#ffffff");

  saveState(state);
  render();
  renderBookView();
});

/* Add subfolder */
addSubBtn.addEventListener("click", () => {
  const state = loadState();
  const book = getCurrentBookFromStack(state);
  if (!book) return;

  const nm = (subName.value || "").trim();
  if (!nm) return alert("Give the subfolder a name.");

  book.children = book.children || [];
  book.children.push(mkBook(nm, subColor.value || "#6b7280", subTextColor.value || "#ffffff"));

  saveState(state);
  subName.value = "";
  render();
  renderBookView();
});

/* Mini shelf open + gear */
miniShelf.addEventListener("click", (e) => {
  const wrap = e.target.closest(".miniBook");
  if (!wrap) return;
  const childId = wrap.dataset.bookId;
  if (!childId) return;

  const act = e.target.closest("button[data-act]")?.dataset.act || "";

  const state = loadState();
  const current = getCurrentBookFromStack(state);
  if (!current) return;

  current.children = current.children || [];
  const idx = current.children.findIndex(x => x.id === childId);
  if (idx < 0) return;
  const child = current.children[idx];

  const openChild = () => {
    bookViewStack.push(childId);
    currentPageIndex = 0;
    setBookViewMode("front");
    renderBookView();
  };

  // üìñ button = Make Active
  if (act === "miniActive") {
    setActiveId(childId);
    render();
    renderBookView();
    return;
  }

  // ‚öôÔ∏è button = Options
  if (act === "miniGear") {
    const choice = prompt(
      `Options for "${child.name}":\n\n` +
      `1 = Delete\n` +
      `2 = Move up\n` +
      `3 = Move down\n\n` +
      `Type a number and press OK.`
    );
    if (!choice) return;

    if (choice === "1") {
      const ok = confirm(`Delete "${child.name}"? (Subsections and notes will also be removed)`);
      if (!ok) return;
      current.children.splice(idx, 1);
      saveState(state);
      render();
      renderBookView();
      return;
    }
    if (choice === "2") { moveItem(current.children, idx, idx - 1); saveState(state); render(); renderBookView(); return; }
    if (choice === "3") { moveItem(current.children, idx, idx + 1); saveState(state); render(); renderBookView(); return; }
    return;
  }

  // Clicking the mini spine/label = OPEN
  openChild();
});

/* Drag reorder minis */
miniShelf.addEventListener("dragover", (e) => e.preventDefault());
miniShelf.addEventListener("drop", (e) => {
  e.preventDefault();
  if (!bvDragBookId) return;

  const state = loadState();
  const current = getCurrentBookFromStack(state);
  if (!current) return;
  current.children = current.children || [];

  const fromIdx = current.children.findIndex(x => x.id === bvDragBookId);
  if (fromIdx < 0) return;

  const targetWrap = e.target.closest(".miniBook");
  const targetId = targetWrap ? targetWrap.dataset.bookId : null;
  let toIdx = targetId ? current.children.findIndex(x => x.id === targetId) : -1;
  if (toIdx < 0) toIdx = current.children.length - 1;
  if (toIdx === fromIdx) return;

  const [moved] = current.children.splice(fromIdx, 1);
  current.children.splice(toIdx, 0, moved);

  saveState(state);
  render();
  renderBookView();
});

/* =============================
   CONTENTS + PAGE JUMP
   ============================= */
function renderContentsForBook(book){
  ensurePages(book);
  const items = book.pages
    .map((p, idx) => ({ idx, title: (p.title || "").trim() }))
    .filter(x => x.title.length > 0)
    .sort((a,b) => a.idx - b.idx);

  contentsList.innerHTML = "";

  if (!items.length) {
    contentsList.innerHTML = `
      <div class="contentsItem" style="cursor:default;">
        <div>
          <div class="contentsTitle" style="opacity:.8;">No titled pages yet</div>
          <div class="contentsMeta">Add a title above your notes to list it here.</div>
        </div>
      </div>
    `;
    return;
  }

  for (const it of items){
    const pnum = it.idx + 1;
    const row = document.createElement("div");
    row.className = "contentsItem";
    row.innerHTML = `
      <div>
        <div class="contentsTitle">${escapeHtml(it.title)}</div>
        <div class="contentsMeta">Page ${pnum}</div>
      </div>
      <div class="contentsMeta">‚ü∂</div>
    `;
    row.addEventListener("click", () => {
      currentPageIndex = it.idx;
      setBookViewMode("notes");
      renderBookView();
    });
    contentsList.appendChild(row);
  }
}

/* =============================
   NOTES PAGE CONTROLS
   ============================= */
function clampPageIndex(book){
  ensurePages(book);
  if (book.pages.length <= 0) book.pages = [{ title:"", text:"" }];
  if (currentPageIndex < 0) currentPageIndex = 0;
  if (currentPageIndex > book.pages.length - 1) currentPageIndex = book.pages.length - 1;
}

function pageStep(){
  return isTwoPageModeActive() ? 2 : 1; // desktop only (isTwoPageModeActive already checks mobile)
}

function goPrevPage(){
  const state = loadState();
  const book = getCurrentBookFromStack(state);
  if (!book) return;
  ensurePages(book);
  clampPageIndex(book);

  const step = pageStep();
  currentPageIndex = Math.max(0, currentPageIndex - step);

  // if in 2-page mode, force left-page alignment
  if (isTwoPageModeActive()) currentPageIndex = currentPageIndex - (currentPageIndex % 2);

  setBookViewMode("notes");
  renderBookView();
}

function goNextPage(){
  const state = loadState();
  const book = getCurrentBookFromStack(state);
  if (!book) return;
  ensurePages(book);
  clampPageIndex(book);

  const step = pageStep();
  currentPageIndex = Math.min(book.pages.length - 1, currentPageIndex + step);

  // if in 2-page mode, force left-page alignment
  if (isTwoPageModeActive()) currentPageIndex = currentPageIndex - (currentPageIndex % 2);

  setBookViewMode("notes");
  renderBookView();
}

prevPageBtn.addEventListener("click", goPrevPage);
nextPageBtn.addEventListener("click", goNextPage);

addLeftPageBtn.addEventListener("click", () => {
  const state = loadState();
  const book = getCurrentBookFromStack(state);
  if (!book) return;

  ensurePages(book);
  clampPageIndex(book);

  // Insert BEFORE the selected page
  const insertAt = Math.max(0, currentPageIndex);

  book.pages.splice(insertAt, 0, { title:"", text:"" });
  book.notes = book.pages[0]?.text ?? "";
  saveState(state);

  currentPageIndex = insertAt; // select the new page
  renderBookView();
});

addRightPageBtn.addEventListener("click", () => {
  const state = loadState();
  const book = getCurrentBookFromStack(state);
  if (!book) return;

  ensurePages(book);
  clampPageIndex(book);

  // Insert AFTER the selected page
  const insertAt = Math.min(book.pages.length, currentPageIndex + 1);

  book.pages.splice(insertAt, 0, { title:"", text:"" });
  book.notes = book.pages[0]?.text ?? "";
  saveState(state);

  currentPageIndex = insertAt; // select the new page
  renderBookView();
});

delPageBtn.addEventListener("click", () => {
  const state = loadState();
  const book = getCurrentBookFromStack(state);
  if (!book) return;
  ensurePages(book);
  clampPageIndex(book);

  if (book.pages.length <= 1) return alert("You can‚Äôt delete the last page.");
  const ok = confirm(`Delete Page ${currentPageIndex + 1}?`);
  if (!ok) return;

  book.pages.splice(currentPageIndex, 1);
  book.notes = book.pages[0]?.text ?? "";
  saveState(state);

  if (currentPageIndex > book.pages.length - 1) currentPageIndex = book.pages.length - 1;
  renderBookView();
});

/* =============================
   SWIPE SUPPORT (Notes)
   ============================= */
let touchStartX = 0;
let touchStartY = 0;
let touchActive = false;

bookPagesEl.addEventListener("touchstart", (e) => {
  if (bookView.dataset.view !== "notes") return;
  const t = e.touches[0];
  touchStartX = t.clientX;
  touchStartY = t.clientY;
  touchActive = true;
}, { passive: true });

bookPagesEl.addEventListener("touchend", (e) => {
  if (bookView.dataset.view !== "notes") return;
  if (!touchActive) return;
  touchActive = false;

  const t = e.changedTouches[0];
  const dx = t.clientX - touchStartX;
  const dy = t.clientY - touchStartY;

  // ignore mostly-vertical swipes (scrolling)
  if (Math.abs(dy) > Math.abs(dx)) return;

  const THRESH = 50;

  // Swipe left = next page
  if (dx <= -THRESH) {
    goNextPage();
    return;
  }

  // Swipe right = prev page, OR if on first page -> Contents
  if (dx >= THRESH) {
    const state = loadState();
    const book = getCurrentBookFromStack(state);
    if (book) {
      ensurePages(book);

      const isFirst =
        window.matchMedia("(max-width: 780px)").matches
          ? (currentPageIndex === 0)
          : ((currentPageIndex - (currentPageIndex % 2)) === 0);

      if (isFirst) {
        setBookViewMode("contents");
        renderBookView();
        return;
      }
    }

    goPrevPage();
    return;
  }
}, { passive: true });

/* =============================
   SWIPE SUPPORT (View navigation)
   Front ‚áÑ Contents ‚áÑ Notes
   ============================= */

let navTouchStartX = 0;
let navTouchStartY = 0;
let navTouchActive = false;

bookView.addEventListener("touchstart", (e) => {
  // Don't hijack swipes inside inputs/notes
  if (e.target.closest("textarea, input, select, button")) return;

  const t = e.touches[0];
  navTouchStartX = t.clientX;
  navTouchStartY = t.clientY;
  navTouchActive = true;
}, { passive: true });

bookView.addEventListener("touchend", (e) => {
  if (!navTouchActive) return;
  navTouchActive = false;

  if (e.target.closest("textarea, input, select, button")) return;

  const t = e.changedTouches[0];
  const dx = t.clientX - navTouchStartX;
  const dy = t.clientY - navTouchStartY;

  // ignore mostly-vertical swipes (scrolling)
  if (Math.abs(dy) > Math.abs(dx)) return;

  const THRESH = 60;
  const view = bookView.dataset.view || "front";

  // Swipe left = forward
  if (dx <= -THRESH) {
    if (view === "front") { setBookViewMode("contents"); renderBookView(); return; }
    if (view === "contents") { setBookViewMode("notes"); renderBookView(); return; }
    return;
  }

  // Swipe right = back
  if (dx >= THRESH) {
    if (view === "notes") { setBookViewMode("contents"); renderBookView(); return; }
    if (view === "contents") { setBookViewMode("front"); renderBookView(); return; }
    return;
  }
}, { passive: true });

/* =============================
   SWIPE SUPPORT (Notes bar)
   Allows Notes ‚áÑ Contents without interfering with textarea editing
   ============================= */

let notesBarStartX = 0;
let notesBarStartY = 0;
let notesBarActive = false;

notesGlobalBar.addEventListener("touchstart", (e) => {
  const t = e.touches[0];
  notesBarStartX = t.clientX;
  notesBarStartY = t.clientY;
  notesBarActive = true;
}, { passive: true });

notesGlobalBar.addEventListener("touchend", (e) => {
  if (!notesBarActive) return;
  notesBarActive = false;

  const t = e.changedTouches[0];
  const dx = t.clientX - notesBarStartX;
  const dy = t.clientY - notesBarStartY;

  // ignore mostly-vertical swipes
  if (Math.abs(dy) > Math.abs(dx)) return;

  const THRESH = 60;
  const view = bookView.dataset.view || "front";

  // Swipe right = back (Notes ‚Üí Contents)
  if (dx >= THRESH) {
    if (view === "notes") { setBookViewMode("contents"); renderBookView(); return; }
    if (view === "contents") { setBookViewMode("front"); renderBookView(); return; }
    return;
  }

  // Swipe left = forward (Contents ‚Üí Notes, Front ‚Üí Contents)
  if (dx <= -THRESH) {
    if (view === "front") { setBookViewMode("contents"); renderBookView(); return; }
    if (view === "contents") { setBookViewMode("notes"); renderBookView(); return; }
    return;
  }
}, { passive: true });

/* =============================
   INLINE SAVING (Titles + Notes)
   ============================= */
function writeCurrentTitle(){
  const state = loadState();
  const book = getCurrentBookFromStack(state);
  if (!book) return;
  ensurePages(book);
  clampPageIndex(book);

  book.pages[currentPageIndex].title = (leftTitleInput.value || "").toString();
  saveState(state);
  renderContentsForBook(book);
}
function writeCurrentNotes(){
  const state = loadState();
  const book = getCurrentBookFromStack(state);
  if (!book) return;
  ensurePages(book);
  clampPageIndex(book);

  book.pages[currentPageIndex].text = leftNotesArea.value;
  book.notes = book.pages[0]?.text ?? "";
  saveState(state);
}

leftTitleInput.addEventListener("input", writeCurrentTitle);
leftNotesArea.addEventListener("input", writeCurrentNotes);

/* Desktop right page inline saving */
rightTitleInput.addEventListener("input", () => {
  const state = loadState();
  const book = getCurrentBookFromStack(state);
  if (!book) return;
  ensurePages(book);

  const rightIndex = currentPageIndex - (currentPageIndex % 2) + 1;
  if (rightIndex >= book.pages.length) return;

  book.pages[rightIndex].title = (rightTitleInput.value || "").toString();
  saveState(state);
  renderContentsForBook(book);
});
rightNotesArea.addEventListener("input", () => {
  const state = loadState();
  const book = getCurrentBookFromStack(state);
  if (!book) return;
  ensurePages(book);

  const rightIndex = currentPageIndex - (currentPageIndex % 2) + 1;
  if (rightIndex >= book.pages.length) return;

  book.pages[rightIndex].text = rightNotesArea.value;
  book.notes = book.pages[0]?.text ?? "";
  saveState(state);
});

/* =============================
   RENDER BOOK VIEW
   ============================= */
function renderBookView(){
  const state = loadState();
  const book = getCurrentBookFromStack(state);
  if (!book) { closeBookView(); return; }

  ensurePages(book);
  clampPageIndex(book);

  // breadcrumbs
  const names = bookViewStack.map(id => {
    const b = findBookById(state.roots, id);
    return b ? b.name : "Unknown";
  });
  bookCrumbs.textContent = names.join(" ‚Ä∫ ");

  // front settings
  bookTitle.textContent = book.name;
  renameInput.value = book.name;
  recolorInput.value = book.color;
  recolorPreview.style.background = book.color;
  reTextColor.value = book.textColor || "#ffffff";
  setTextPreview(reTextPreview, book.color, reTextColor.value);

  // contents list
  renderContentsForBook(book);

  // notes global indicator
  if (isTwoPageModeActive() && !window.matchMedia("(max-width: 780px)").matches) {
  const leftIndex = currentPageIndex - (currentPageIndex % 2);
  const rightIndex = Math.min(leftIndex + 1, book.pages.length - 1);
  pageIndicator.textContent = `Pages ${leftIndex + 1}‚Äì${rightIndex + 1} / ${book.pages.length}`;
} else {
  pageIndicator.textContent = `Page ${currentPageIndex + 1} / ${book.pages.length}`;
}

  // ‚úÖ Mobile integrated mode uses left panel as the single page
  const isMobile = window.matchMedia("(max-width: 780px)").matches;

  if (bookView.dataset.view === "notes"){
    notesGlobalBar.style.display = "block";
  } else {
    notesGlobalBar.style.display = "none";
  }

  if (bookView.dataset.view === "notes") {
    if (isMobile) {
      const p = book.pages[currentPageIndex];
      notesTitleLabel.textContent = `Chapter title (Page ${currentPageIndex + 1})`;
      notesTextLabel.textContent  = `Notes (Page ${currentPageIndex + 1})`;
      leftTitleInput.value = p?.title ?? "";
      leftNotesArea.value = p?.text ?? "";
    } else {
      // Desktop: show the spread that contains currentPageIndex
      const leftIndex = currentPageIndex - (currentPageIndex % 2);
      const rightIndex = leftIndex + 1;

      const L = book.pages[leftIndex];
      const R = (rightIndex < book.pages.length) ? book.pages[rightIndex] : null;

      // left (odd page)
      notesTitleLabel.textContent = `Chapter title (Page ${leftIndex + 1})`;
      notesTextLabel.textContent  = `Notes (Page ${leftIndex + 1})`;
      leftTitleInput.value = L?.title ?? "";
      leftNotesArea.value = L?.text ?? "";

notesLeftPage.classList.toggle("selected", currentPageIndex === leftIndex);
notesRightPage.classList.toggle("selected", currentPageIndex === rightIndex);

// right (even page)
if (R) {
  rightTitleInput.disabled = false;
  rightNotesArea.disabled = false;

  if (rightTitleLabel) rightTitleLabel.textContent = `Chapter title (Page ${rightIndex + 1})`;
  if (rightNotesLabel) rightNotesLabel.textContent = `Notes (Page ${rightIndex + 1})`;

  rightTitleInput.value = R.title ?? "";
  rightNotesArea.value = R.text ?? "";
} else {
  rightTitleInput.disabled = true;
  rightNotesArea.disabled = true;

  if (rightTitleLabel) rightTitleLabel.textContent = `Chapter title (Page ${rightIndex + 1})`;
  if (rightNotesLabel) rightNotesLabel.textContent = `Notes (Page ${rightIndex + 1})`;

  rightTitleInput.value = "";
  rightNotesArea.value = "";
}
    }
  }

  // mini shelf render
  miniShelf.innerHTML = "";
  (book.children || []).forEach(child => {
    const wrap = document.createElement("div");
    wrap.className = "miniBook";
    wrap.dataset.bookId = child.id;

    const activeId = getActiveId();
    if (child.id !== activeId) {
      wrap.draggable = true;
      wrap.addEventListener("dragstart", (e) => {
        bvDragBookId = child.id;
        wrap.classList.add("dragging");
        e.dataTransfer.effectAllowed = "move";
      });
      wrap.addEventListener("dragend", () => {
        bvDragBookId = null;
        wrap.classList.remove("dragging");
      });
    } else {
      wrap.draggable = false;
      wrap.style.opacity = "0.55";
    }

    wrap.innerHTML = `
      <div class="miniSpine" style="background:${child.color}">
        <span style="color:${child.textColor || "#ffffff"}">${escapeHtml(child.name)}</span>
      </div>
      <button type="button" class="miniOpenBtn" data-act="miniActive" title="Make active">üìñ</button>
      <button type="button" class="miniGearBtn" data-act="miniGear" title="Options">‚öôÔ∏è</button>
    `;
    miniShelf.appendChild(wrap);
  });

  // persist open view state
  persistOpenState();
}

/* =============================
   AUTO RESTORE LAST PLACE
   ============================= */
function restoreOnLoad(){
  // if we were last in a folder, path is already saved and used by render()
  // reopen last open book if it was open
  const bv = loadBookViewState();
  if (bv && bv.isOpen) openBookViewFromSaved();
}

/* =============================
   FIRST RENDER
   ============================= */
render();
restoreOnLoad();

</script>
</body>
</html>
